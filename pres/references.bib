
@misc{sebastian_ullrich_formal_nodate,
	type = {Blog},
	title = {A {Formal} {Verification} of {Rust}'s {Binary} {Search} {Implementation}},
	url = {https://kha.github.io/2016/07/22/formally-verifying-rusts-binary-search.html},
	urldate = {2020-11-05},
	journal = {The Axiom of False},
	author = {{Sebastian Ullrich}},
	file = {A Formal Verification of Rust's Binary Search Implementation:/home/storm/Zotero/storage/SMD3K6CJ/formally-verifying-rusts-binary-search.html:text/html},
}

@article{astrauskas_leveraging_2019,
	title = {Leveraging rust types for modular specification and verification},
	volume = {3},
	url = {https://doi.org/10.1145/3360573},
	doi = {10.1145/3360573},
	abstract = {Rust's type system ensures memory safety: well-typed Rust programs are guaranteed to not exhibit problems such as dangling pointers, data races, and unexpected side effects through aliased references. Ensuring correctness properties beyond memory safety, for instance, the guaranteed absence of assertion failures or more-general functional correctness, requires static program verification. For traditional system programming languages, formal verification is notoriously difficult and requires complex specifications and logics to reason about pointers, aliasing, and side effects on mutable state. This complexity is a major obstacle to the more-widespread verification of system software. In this paper, we present a novel verification technique that leverages Rust's type system to greatly simplify the specification and verification of system software written in Rust. We analyse information from the Rust compiler and synthesise a corresponding core proof for the program in a flavour of separation logic tailored to automation. To verify correctness properties beyond memory safety, users can annotate Rust programs with specifications at the abstraction level of Rust expressions; our technique weaves them into the core proof to verify modularly whether these specifications hold. Crucially, our proofs are constructed and checked automatically without exposing the underlying formal logic, allowing users to work exclusively at the level of abstraction of the programming language. As such, our work enables a new kind of verification tool, with the potential to impact a wide audience and allow the Rust community to benefit from state-of-the-art verification techniques. We have implemented our techniques for a subset of Rust; our evaluation on several thousand functions from widely-used Rust crates demonstrates its effectiveness.},
	number = {OOPSLA},
	urldate = {2020-11-05},
	journal = {Proceedings of the ACM on Programming Languages},
	author = {Astrauskas, Vytautas and Müller, Peter and Poli, Federico and Summers, Alexander J.},
	month = oct,
	year = {2019},
	keywords = {concurrency, heap-manipulating programs, Rust, type systems},
	pages = {147:1--147:30},
	file = {Full Text PDF:/home/storm/Zotero/storage/XG2HUWYK/Astrauskas et al. - 2019 - Leveraging rust types for modular specification an.pdf:application/pdf},
}

@phdthesis{sebastian_ullrich_simple_nodate,
	title = {Simple {Verification} of {RustPrograms} via {FunctionalPurification}},
	url = {https://raw.githubusercontent.com/Kha/masters-thesis/master/main.pdf},
	abstract = {Imperative programming, and aliasing in particular, represents a major obstacle in formally reasoning about everyday code. By utilizing restrictions the imperative programming language Rust imposes on mutable aliasing, we present a scheme for shallowly embedding a substantial part of the Rust language into the purely functional language of the Lean theorem prover. We use this scheme to verify the correctness of real-world examples of Rust code without the need for special semantics or logics. We furthermore show the extensibility of our transformation by incorporating an analysis of asymptotic runtimes.},
	language = {English},
	school = {Karlsruhe Institute of Technology},
	author = {{Sebastian Ullrich}},
	file = {Ullrich - Simple Verification of RustPrograms via Functional.pdf:/home/storm/Zotero/storage/YHYICUWJ/Ullrich - Simple Verification of RustPrograms via Functional.pdf:application/pdf;presentation.pdf:/home/storm/Zotero/storage/UL86BKAN/presentation.pdf:application/pdf},
}

@inproceedings{de_moura_lean_2015,
	address = {Cham},
	series = {Lecture {Notes} in {Computer} {Science}},
	title = {The {Lean} {Theorem} {Prover} ({System} {Description})},
	isbn = {978-3-319-21401-6},
	doi = {10.1007/978-3-319-21401-6_26},
	abstract = {Lean is a new open source theorem prover being developed at Microsoft Research and Carnegie Mellon University, with a small trusted kernel based on dependent type theory. It aims to bridge the gap between interactive and automated theorem proving, by situating automated tools and methods in a framework that supports user interaction and the construction of fully specified axiomatic proofs. Lean is an ongoing and long-term effort, but it already provides many useful components, integrated development environments, and a rich API which can be used to embed it into other systems. It is currently being used to formalize category theory, homotopy type theory, and abstract algebra. We describe the project goals, system architecture, and main features, and we discuss applications and continuing work.},
	language = {en},
	booktitle = {Automated {Deduction} - {CADE}-25},
	publisher = {Springer International Publishing},
	author = {de Moura, Leonardo and Kong, Soonho and Avigad, Jeremy and van Doorn, Floris and von Raumer, Jakob},
	editor = {Felty, Amy P. and Middeldorp, Aart},
	year = {2015},
	keywords = {Automate Theorem Prove, Theorem Prove, Trust Level, Type Checker, Type Class},
	pages = {378--388},
	file = {de Moura et al. - 2015 - The Lean Theorem Prover (System Description).pdf:/home/storm/Zotero/storage/2I927N94/de Moura et al. - 2015 - The Lean Theorem Prover (System Description).pdf:application/pdf},
}

@article{coquand_calculus_1988,
	title = {The calculus of constructions},
	volume = {76},
	issn = {0890-5401},
	url = {http://www.sciencedirect.com/science/article/pii/0890540188900053},
	doi = {10.1016/0890-5401(88)90005-3},
	language = {en},
	number = {2},
	urldate = {2020-11-06},
	journal = {Information and Computation},
	author = {Coquand, Thierry and Huet, Gérard},
	month = feb,
	year = {1988},
	pages = {95--120},
	file = {ScienceDirect Snapshot:/home/storm/Zotero/storage/IVSU92KS/0890540188900053.html:text/html;Coquand and Huet - 1988 - The calculus of constructions.pdf:/home/storm/Zotero/storage/7TLLXZLT/Coquand and Huet - 1988 - The calculus of constructions.pdf:application/pdf},
}

@misc{noauthor_rust-proofrustproof_2020,
	title = {Rust-{Proof}/rustproof},
	copyright = {View license         ,                 View license},
	url = {https://github.com/Rust-Proof/rustproof},
	abstract = {rust verification condition generator. Contribute to Rust-Proof/rustproof development by creating an account on GitHub.},
	urldate = {2020-11-07},
	publisher = {Rust-Proof},
	month = aug,
	year = {2020},
	note = {original-date: 2016-05-03T02:23:56Z},
}

@book{thompson_type_1991,
	title = {Type theory and functional programming},
	publisher = {Addison Wesley},
	author = {Thompson, Simon},
	year = {1991},
	file = {Thompson - 1991 - Type theory and functional programming.pdf:/home/storm/Zotero/storage/HGAIM4KZ/Thompson - 1991 - Type theory and functional programming.pdf:application/pdf},
}
